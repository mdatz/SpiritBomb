const qBuildCacheName = 'QwikBuild';
const existingPrefetches = new Set();
const awaitingRequests = new Map();

const getCacheToDelete = (appBundles, cachedUrls) => {
    return cachedUrls.filter((url) => !appBundles.some((appBundle) => url.endsWith(appBundle[0])));
};
const useCache = (request, response) => !!response && !hasNoCacheHeader(request) && !hasNoCacheHeader(response);
const hasNoCacheHeader = (r) => {
    const cacheControl = r.headers.get('Cache-Control') || '';
    return cacheControl.includes('no-cache') || cacheControl.includes('max-age=0');
};
const isAppBundleRequest = (appBundles, requestPathname) => appBundles.some((b) => requestPathname.endsWith('/' + b[0]));
const getAppBundleByName = (appBundles, appBundleName) => appBundles.find((b) => b[0] === appBundleName);
const getAppBundlesNamesFromIds = (appBundles, bundleIds) => bundleIds.map((bundleId) => (appBundles[bundleId] ? appBundles[bundleId][0] : null));

const cachedFetch = (cache, fetch, awaitingRequests, request) => new Promise((promiseResolve, promiseReject) => {
    const url = request.url;
    const awaitingRequestResolves = awaitingRequests.get(url);
    if (awaitingRequestResolves) {
        // there's already an active request happening
        // don't start a new request
        awaitingRequestResolves.push([promiseResolve, promiseReject]);
    }
    else {
        // there isn't already an active request for this url
        // start a new request
        const resolve = (response) => {
            // the response has been resolved
            const resolves = awaitingRequests.get(url);
            if (resolves) {
                // loop through each of the active request
                awaitingRequests.delete(url);
                for (const [awaitingResolve] of resolves) {
                    // clone a new response for each of the active requests
                    awaitingResolve(response.clone());
                }
            }
            else {
                // somehow the array of awaiting requests doesn't exist
                promiseResolve(response.clone());
            }
        };
        const reject = (msg) => {
            const resolves = awaitingRequests.get(url);
            if (resolves) {
                awaitingRequests.delete(url);
                for (const [_, awaitingReject] of resolves) {
                    awaitingReject(msg);
                }
            }
            else {
                promiseReject(msg);
            }
        };
        // create a new array of the request waiting to be resolved
        awaitingRequests.set(url, [[promiseResolve, promiseReject]]);
        cache
            .match(url)
            .then((cachedResponse) => {
            if (useCache(request, cachedResponse)) {
                // cached response found and user did not specifically send
                // a request header to NOT use the cache (wasn't a hard refresh)
                resolve(cachedResponse);
            }
            else {
                // no cached response found or user didn't want to use the cache
                // do a full network request
                return fetch(request).then((networkResponse) => {
                    return cache.put(url, networkResponse.clone()).then(() => {
                        resolve(networkResponse);
                    });
                });
            }
        })
            .catch((err) => {
            // network error, probably offline
            return cache.match(url).then((cachedResponse) => {
                if (cachedResponse) {
                    // luckily we have a cached version, let's use it instead of an offline message
                    resolve(cachedResponse);
                }
                else {
                    // darn, we've got no connectivity and no cached response
                    // respond with a 503 offline message
                    reject(err);
                }
            });
        });
    }
});

const prefetchBundleNames = (appBundles, qBuildCache, fetch, baseUrl, prefetchAppBundleNames) => {
    const prefetchAppBundle = (prefetchAppBundleName) => {
        try {
            const appBundle = getAppBundleByName(appBundles, prefetchAppBundleName);
            if (appBundle && !existingPrefetches.has(prefetchAppBundleName)) {
                existingPrefetches.add(prefetchAppBundleName);
                const importedBundleNames = getAppBundlesNamesFromIds(appBundles, appBundle[1]);
                const url = new URL(prefetchAppBundleName, baseUrl);
                const request = new Request(url);
                cachedFetch(qBuildCache, fetch, awaitingRequests, request);
                importedBundleNames.forEach(prefetchAppBundle);
            }
        }
        catch (e) {
            console.error(e);
        }
    };
    if (Array.isArray(prefetchAppBundleNames)) {
        prefetchAppBundleNames.forEach(prefetchAppBundle);
    }
};
const prefetchLinkBundles = (appBundles, libraryBundleIds, linkBundles, qBuildCache, fetch, baseUrl, linkPathnames) => {
    try {
        prefetchBundleNames(appBundles, qBuildCache, fetch, baseUrl, getAppBundlesNamesFromIds(appBundles, libraryBundleIds));
    }
    catch (e) {
        console.error(e);
    }
    for (const linkPathname of linkPathnames) {
        try {
            for (const linkBundle of linkBundles) {
                const [route, linkBundleIds] = linkBundle;
                console;
                if (route.test(linkPathname)) {
                    prefetchBundleNames(appBundles, qBuildCache, fetch, baseUrl, getAppBundlesNamesFromIds(appBundles, linkBundleIds));
                    break;
                }
            }
        }
        catch (e) {
            console.error(e);
        }
    }
};
const prefetchWaterfall = (appBundles, qBuildCache, fetch, requestedBuildUrl) => {
    try {
        const segments = requestedBuildUrl.href.split('/');
        const requestedBundleName = segments[segments.length - 1];
        segments[segments.length - 1] = '';
        const baseUrl = new URL(segments.join('/'));
        prefetchBundleNames(appBundles, qBuildCache, fetch, baseUrl, [requestedBundleName]);
    }
    catch (e) {
        console.error(e);
    }
};

const setupServiceWorkerScope = (swScope, appBundles, libraryBundleIds, linkBundles) => {
    swScope.addEventListener('fetch', (ev) => {
        const request = ev.request;
        if (request.method === 'GET') {
            const url = new URL(request.url);
            if (isAppBundleRequest(appBundles, url.pathname)) {
                const nativeFetch = swScope.fetch.bind(swScope);
                ev.respondWith(swScope.caches.open(qBuildCacheName).then((qBuildCache) => {
                    prefetchWaterfall(appBundles, qBuildCache, nativeFetch, url);
                    return cachedFetch(qBuildCache, nativeFetch, awaitingRequests, request);
                }));
            }
        }
    });
    swScope.addEventListener('message', async ({ data }) => {
        if (data.type === 'qprefetch' && typeof data.base === 'string') {
            const nativeFetch = swScope.fetch.bind(swScope);
            const qBuildCache = await swScope.caches.open(qBuildCacheName);
            const baseUrl = new URL(data.base, swScope.origin);
            if (Array.isArray(data.links)) {
                prefetchLinkBundles(appBundles, libraryBundleIds, linkBundles, qBuildCache, fetch, baseUrl, data.links);
            }
            if (Array.isArray(data.bundles)) {
                prefetchBundleNames(appBundles, qBuildCache, nativeFetch, baseUrl, data.bundles);
            }
        }
    });
    swScope.addEventListener('activate', async () => {
        try {
            const qBuildCache = await swScope.caches.open(qBuildCacheName);
            const cachedRequestKeys = await qBuildCache.keys();
            const cachedUrls = cachedRequestKeys.map((r) => r.url);
            const cachedRequestsToDelete = getCacheToDelete(appBundles, cachedUrls);
            await Promise.all(cachedRequestsToDelete.map((r) => qBuildCache.delete(r)));
        }
        catch (e) {
            console.error(e);
        }
    });
};

/**
 * @alpha
 */
const setupServiceWorker = () => {
    if (typeof self !== 'undefined' && typeof appBundles !== 'undefined') {
        setupServiceWorkerScope(self, appBundles, libraryBundleIds, linkBundles);
    }
};

export { setupServiceWorker };
